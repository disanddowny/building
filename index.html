<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>반지하 2033 광기의 트럭</title>
    <style>
        :root {
            --primary-color: #3a3a3c;
            --secondary-color: #2c2c2e;
            --accent-color: #ff9500;
            --text-color: #f5f5f7;
            --border-color: #515154;
            --danger-color: #ff3b30;
            --success-color: #34c759;
            --warning-color: #ffcc00;
            --info-color: #5ac8fa;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--primary-color);
            color: var(--text-color);
            padding: 20px;
            max-width: 1000px;
            margin: 0 auto;
        }
        
        .game-container {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
        }
        
        .resources-panel {
            background-color: var(--secondary-color);
            border-radius: 8px;
            padding: 15px;
            border: 1px solid var(--border-color);
            margin-bottom: 20px;
        }
        
        .resource-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .resource-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(0,0,0,0.2);
            padding: 8px 12px;
            border-radius: 4px;
        }
        
        .resource-icon {
            width: 24px;
            height: 24px;
            margin-right: 8px;
            display: inline-block;
            text-align: center;
        }
        
        .resource-value {
            font-weight: bold;
            color: var(--accent-color);
        }
        
        h1, h2, h3 {
            margin-bottom: 15px;
            color: var(--accent-color);
        }
        
        .characters-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .character-card {
            background-color: var(--secondary-color);
            border-radius: 8px;
            padding: 15px;
            border: 1px solid var(--border-color);
            position: relative;
            z-index: 1;
        }
        
        .character-card.dead {
            opacity: 0.6;
            background-color: #222;
        }
        
        .character-name {
            font-size: 1.2em;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            position: relative;
            z-index: 2;
        }
        
        .selected-action {
            font-size: 0.9em;
            color: var(--accent-color);
            padding: 4px 8px;
            background-color: rgba(255, 149, 0, 0.2);
            border-radius: 4px;
            border: 1px solid var(--accent-color);
            white-space: nowrap;
            display: inline-block;
            position: relative;
            z-index: 3;
        }
        
        .character-trait {
            font-size: 0.9em;
            margin-bottom: 10px;
            font-style: italic;
            color: #aaa;
        }
        
        .status-labels {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        .status-label {
            font-size: 0.8em;
            padding: 3px 8px;
            border-radius: 4px;
            background-color: var(--danger-color);
        }
        
        .status-label.depressed {
            background-color: var(--warning-color);
            color: black;
        }
        
        .status-label.injured {
            background-color: var(--danger-color);
        }
        
        .status-label.dead {
            background-color: black;
        }
        
        .actions-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            position: relative;
            z-index: 1;
        }
        
        .action-button {
            padding: 8px;
            border: none;
            border-radius: 4px;
            background-color: #515154;
            color: white;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .action-button:hover {
            background-color: #6d6d70;
        }
        
        .action-button:disabled {
            background-color: #3a3a3c;
            color: #8e8e93;
            cursor: not-allowed;
        }

        .action-button.selected {
            background-color: var(--accent-color);
            color: black;
            font-weight: bold;
            box-shadow: 0 0 10px var(--accent-color);
            animation: glow 1.5s infinite alternate;
        }

        @keyframes glow {
            from {
                box-shadow: 0 0 5px var(--accent-color);
            }
            to {
                box-shadow: 0 0 15px var(--accent-color);
            }
        }
        
        .action-tooltip {
            position: fixed;
            background-color: rgba(0,0,0,0.95);
            padding: 8px 12px;
            border-radius: 4px;
            width: 200px;
            z-index: 1000;
            display: none;
            font-size: 0.85em;
            line-height: 1.4;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            border: 1px solid var(--border-color);
            pointer-events: none;
        }
        
        .action-button:hover .action-tooltip {
            display: block;
        }
        
        .game-panel {
            background-color: var(--secondary-color);
            border-radius: 8px;
            padding: 15px;
            border: 1px solid var(--border-color);
        }
        
        .end-turn-container {
            margin-top: 20px;
            text-align: center;
        }
        
        .end-turn-button {
            padding: 12px 24px;
            background-color: var(--accent-color);
            color: black;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            font-size: 1.1em;
        }
        
        .end-turn-button:disabled {
            background-color: #8e8e93;
            cursor: not-allowed;
        }
        
        .message-log {
            background-color: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            margin-top: 20px;
            border: 1px solid var(--border-color);
        }
        
        .message {
            margin-bottom: 10px;
            line-height: 1.4;
            padding-left: 10px;
            border-left: 3px solid var(--border-color);
        }
        
        .continue-button {
            margin-top: 10px;
            padding: 8px 16px;
            background-color: var(--accent-color);
            color: black;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .game-status {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        
        .game-status-item {
            font-weight: bold;
        }
        
        .progress-container {
            height: 20px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        .progress-bar {
            height: 100%;
            background-color: var(--success-color);
            transition: width 0.3s ease;
        }
        
        .progress-bar.defense {
            background-color: var(--info-color);
        }
        
        .progress-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .modal-content {
            background-color: var(--primary-color);
            padding: 20px;
            border-radius: 8px;
            max-width: 500px;
            text-align: center;
        }
        
        .modal-title {
            font-size: 1.5em;
            margin-bottom: 15px;
        }
        
        .modal-button {
            padding: 10px 20px;
            margin-top: 20px;
            background-color: var(--accent-color);
            color: black;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        /* 캐릭터 선택 모달 스타일 */
        .character-select-content {
            max-width: 800px;
            width: 90%;
        }

        .selection-info {
            text-align: center;
            margin: 15px 0;
            font-size: 1.1em;
        }

        .selected-count, .remaining-points {
            margin: 5px 0;
        }

        .character-select-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .character-select-button {
            background-color: var(--secondary-color);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .character-select-button:hover {
            border-color: var(--accent-color);
            transform: translateY(-2px);
        }

        .character-select-button.selected {
            border-color: var(--accent-color);
            background-color: rgba(255, 149, 0, 0.1);
        }

        .character-select-button.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: var(--border-color);
            background-color: rgba(0, 0, 0, 0.2);
            pointer-events: none;
            filter: grayscale(100%);
        }

        .character-select-button.disabled:hover {
            transform: none;
            border-color: var(--border-color);
        }

        .character-select-button.disabled .character-name {
            color: var(--text-color);
            opacity: 0.7;
        }

        .character-select-button.disabled .character-points {
            color: var(--danger-color);
        }

        .character-select-button .character-name {
            font-size: 1.2em;
            margin-bottom: 8px;
            color: var(--accent-color);
        }

        .character-select-button .character-trait {
            font-size: 0.9em;
            color: var(--text-color);
            opacity: 0.8;
        }

        .character-select-button .trait-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.9);
            padding: 8px 12px;
            border-radius: 4px;
            width: 200px;
            z-index: 100;
            display: none;
            font-size: 0.85em;
            line-height: 1.4;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .character-select-button:hover .trait-tooltip {
            display: block;
        }

        #start-game-button:disabled {
            background-color: #8e8e93;
            cursor: not-allowed;
        }

        .character-points {
            font-size: 0.8em;
            color: var(--accent-color);
            margin-left: 5px;
        }

        #character-select-modal {
            z-index: 900;
        }

        #night-events-modal {
            z-index: 1100;
        }
    </style>
</head>
<body>
    <h1>반지하 2033 광기의 트럭</h1>
    
    <div class="game-container">
        <div class="left-panel">
            <div class="resources-panel">
                <h2>자원</h2>
                <div class="resource-grid">
                    <div class="resource-item">
                        <div><span class="resource-icon">🥩</span> 고기</div>
                        <div class="resource-value" id="meat-value">3</div>
                    </div>
                    <div class="resource-item">
                        <div><span class="resource-icon">🥕</span> 야채</div>
                        <div class="resource-value" id="vegetables-value">3</div>
                    </div>
                    <div class="resource-item">
                        <div><span class="resource-icon">🔧</span> 부품</div>
                        <div class="resource-value" id="parts-value">0</div>
                    </div>
                    <div class="resource-item">
                        <div><span class="resource-icon">🍺</span> 술</div>
                        <div class="resource-value" id="alcohol-value">0</div>
                    </div>
                </div>
            </div>
            
            <div class="game-panel">
                <div class="game-status">
                    <div class="game-status-item">날짜: <span id="day-value">1</span>일차 <span id="time-period">낮</span></div>
                </div>
                
                <div class="progress-label">
                    <span>트럭 내구도</span>
                    <span id="truck-value">0%</span>
                </div>
                <div class="progress-container">
                    <div class="progress-bar" id="truck-bar" style="width: 0%;"></div>
                </div>
                
                <div class="progress-label">
                    <span>캠프 방어도</span>
                    <span id="defense-value">100%</span>
                </div>
                <div class="progress-container">
                    <div class="progress-bar defense" id="defense-bar" style="width: 100%;"></div>
                </div>
                
                <div class="end-turn-container">
                    <button id="end-turn-button" class="end-turn-button">턴 종료</button>
                </div>
            </div>
            
            <div class="message-log" id="message-log">
                <div class="message">트럭을 타고 폐허 서울을 신나게 누비던 반지하 패거리! 그러나 갑자기 트럭이 고장나며 외딴 곳에 멈추고 말았습니다. 위험한 세력이 덮치기 전에 트럭을 수리하고 떠나야 합니다.</div>
            </div>
        </div>
        
        <div class="characters-container" id="characters-container">
            <!-- 캐릭터 카드들이 JavaScript로 동적 생성됩니다 -->
        </div>
    </div>
    
    <div id="game-over-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <h2 class="modal-title" id="modal-title">게임 종료</h2>
            <p id="modal-message">모든 생존자가 죽었습니다.</p>
            <button class="modal-button" onclick="restartGame()">다시 시작</button>
        </div>
    </div>
    
    <div id="night-events-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <h2 class="modal-title">밤 이벤트</h2>
            <p id="night-event-message"></p>
            <button class="modal-button" id="continue-night-button">계속</button>
        </div>
    </div>
    
    <div id="character-select-modal" class="modal">
        <div class="modal-content character-select-content">
            <h2 class="modal-title">캐릭터 선택</h2>
            <p>총 4명의 캐릭터를 선택해주세요.</p>
            <div class="character-select-grid" id="character-select-grid">
                <!-- 캐릭터 버튼들이 JavaScript로 동적 생성됩니다 -->
            </div>
            <div class="selection-info">
                <div class="selected-count">선택된 캐릭터: <span id="selected-count">0</span>/4</div>
                <div class="remaining-points">남은 포인트: <span id="remaining-points">4</span>pt</div>
            </div>
            <button class="modal-button" id="start-game-button" disabled>게임 시작</button>
        </div>
    </div>
    
    <script>
        // 캐릭터 정의
        const allCharacters = {
            yebbi: {
                id: 'yebbi',
                name: '예삐',
                trait: '사냥꾼',
                description: '위험하지만 숲에서 추가로 고기 2개를 가져옵니다.',
                points: 3
            },
            seohyun: {
                id: 'seohyun',
                name: '신서현',
                trait: '수석 개발자',
                description: '수리와 건설 효과가 2배가 됩니다.',
                points: 3
            },
            pilgeun: {
                id: 'pilgeun',
                name: '차필근',
                trait: '파티 플래너',
                description: '술을 소모해 [파티 준비] 행동을 할 수 있습니다.',
                points: 2
            }, 
            minji: {
                id: 'minji',
                name: '김민지',
                trait: '가상세계 은둔자',
                description: '폐허와 암시장에서 부상당하지 않습니다.',
                points: 2
            },
            chulyong: {
                id: 'chulyong',
                name: '김철용',
                trait: '운전병',
                description: '트럭 내구도가 50% 이상이면 아무도 폐허에서 부상당하지 않습니다.',
                points: 1
            },     
            yuwon: {
                id: 'yuwon',
                name: '이유원',
                trait: '도박사',
                description: '[암시장 보내기]가 [도박장 보내기]로 변경됩니다.',
                points: 1
            },
            seohyeop: {
                id: 'seohyeop',
                name: '김세협',
                trait: '시인',
                description: '밤에 15% 확률로 시를 지어줍니다.',
                points: 1
            },
            
            jinyoung: {
                id: 'jinyoung',
                name: '최진영',
                trait: '불면증 환자',
                description: '경계 효과가 2배가 되지만 그 후 우울해집니다.',
                points: 1
            },
            jiwon: {
                id: 'jiwon',
                name: '홍지원',
                trait: '사냥개 조련사',
                description: '지옥에서 온 사냥개 망고가 15% 확률로 갱단을 물리칩니다.',
                points: 1
            },
             wonbin: {
                id: 'wonbin',
                name: '우원빈',
                trait: '선교사',
                description: '한 번에 2명 이상을 간호하면 행복해집니다.',
                points: 1
            },
            yoonji: {
                id: 'yoonji',
                name: '정윤지',
                trait: '채식주의자',
                description: '고기를 먹지 못하고 야채만 먹을 수 있습니다.',
                points: 0
            },
            jaeyoung: {
                id: 'jaeyoung',
                name: '장재영',
                trait: '사이코패스',
                description: '간호할 수 없습니다.',
                points: 0
            },
            sungkook: {
                id: 'sungkook',
                name: '오성국',
                trait: '대식가',
                description: '하루에 식량을 2개씩 소비합니다.',
                points: -1
            },
            geonhee: {
                id: 'geonhee',
                name: '김건희',
                trait: '고관절 환자',
                description: '밤마다 50% 확률로 부상당합니다. 부품 3개로 [고관절 개조]를 해야합니다.',
                points: -1
            },
            gunsoo: {
                id: 'gunsoo',
                name: '양건수',
                trait: '사랑꾼',
                description: '밤에 15% 확률로 고백합니다.',
                points: -1
            }
        };

        // 게임 상태
        const gameState = {
            day: 1,
            isNight: false,
            truckDurability: 0,
            defenseFortification: 1, // 기본 방어도 증가량
            defense: 100,
            resources: {
                meat: 2,
                vegetables: 2,
                parts: 0,
                alcohol: 0
            },
            // 특별 이벤트 상태 추가
            forestResourceReduced: false,
            ruinsInjuryIncreased: false,
            characters: [
                {
                    id: 'yoonji',
                    name: '정윤지',
                    trait: '고기는 못 먹고 야채만 먹을 수 있다',
                    action: null,
                    injured: false,
                    depressed: false,
                    dead: false,
                    happy: false
                },
                {
                    id: 'seohyun',
                    name: '신서현',
                    trait: '수리 효과가 2배가 된다',
                    action: null,
                    injured: false,
                    depressed: false,
                    dead: false,
                    happy: false
                },
                {
                    id: 'pilgeun',
                    name: '차필근',
                    trait: '파티 준비를 할 수 있다',
                    action: null,
                    injured: false,
                    depressed: false,
                    dead: false,
                    preparingParty: false,
                    happy: false
                },
                {
                    id: 'sungkook',
                    name: '오성국',
                    trait: '하루에 식량 2개를 소비한다',
                    action: null,
                    injured: false,
                    depressed: false,
                    dead: false,
                    happy: false
                }
            ],
            nightMessages: [],
            currentMessageIndex: 0,
            remainingPoints: 4
        };

        // 행동 정의
        const actions = {
            forest: {
                name: '숲 보내기',
                description: '숲에서 식량을 찾아본다.',
                isAvailable: (character) => !character.dead && !character.injured,
                execute: (character) => {
                    let prefix = '';
                    if (character.happy) prefix = '(싱글벙글) ';
                    // 윤지는 야채만 0-2개 가져옴
                    if (character.name === '정윤지') {
                        let min = character.happy ? 1 : 0;
                        let max = gameState.forestResourceReduced ? 1 : 2; // 자원 고갈 시 최대 1개
                        const vegetablesFound = Math.floor(Math.random() * (max - min + 1)) + min;
                        gameState.resources.vegetables += vegetablesFound;
                        return `${prefix}숲에 가서 야채 ${vegetablesFound}개를 가져왔어.`;
                    } else {
                        let min = character.happy ? 1 : 0;
                        let max = gameState.forestResourceReduced ? 1 : 2; // 자원 고갈 시 최대 1개
                        const meatFound = Math.floor(Math.random() * (max - min + 1)) + min;
                        const vegetablesFound = Math.floor(Math.random() * (max - min + 1)) + min;
                        gameState.resources.meat += meatFound;
                        gameState.resources.vegetables += vegetablesFound;
                        
                        // 예삐는 추가로 고기 2개를 가져옴
                        if (character.name === '예삐') {
                            // 15% 확률로 사냥 실패
                            if (Math.random() < 0.15) {
                                character.injured = true;
                                if (character.happy) {
                                    setHappy(character, false);
                                    return `${prefix}사냥감이 역으로 덤벼들었네... 부상을 입었다네...`;
                                }
                                return `${prefix}사냥감이 역으로 덤벼들었네... 부상을 입었다네...`;
                            }
                            
                            gameState.resources.meat += 2;
                            return `${prefix}사냥에 성공했네! 고기 ${meatFound + 2}개, 야채 ${vegetablesFound}개를 가져왔다네.`;
                        }
                        
                        return `${prefix}숲에 가서 고기 ${meatFound}개, 야채 ${vegetablesFound}개를 가져왔어.`;
                    }
                }
            },
            ruins: {
                name: '폐허 보내기',
                description: '페허에서 쓸만한 걸 찾아본다.',
                isAvailable: (character) => !character.dead && !character.injured,
                execute: (character) => {
                    let prefix = '';
                    if (character.happy) prefix = '(싱글벙글) ';
                    let min = character.happy ? 1 : 0;
                    const partsFound = Math.floor(Math.random() * (2 - min)) + min; // min~1
                    const alcoholFound = Math.floor(Math.random() * (2 - min)) + min; // min~1
                    gameState.resources.parts += partsFound;
                    gameState.resources.alcohol += alcoholFound;
                    let message = `${prefix}폐허에 가서 부품 ${partsFound}개, 술 ${alcoholFound}개를 가져왔어.`;
                    
                    // 김건희의 고관절 개조 후 특수 능력
                    if (character.name === '김건희' && character.hasHipSurgery) {
                        gameState.resources.parts += 1;
                        message = `${prefix}폐허에 가서 부품 ${partsFound + 1}개, 술 ${alcoholFound}개를 가져왔어. 사이보그 고관절 덕분이야!`;
                    }
                    
                    // 김철용의 특수 능력: 트럭 내구도 50% 이상이면 부상 방지
                    const chulyong = gameState.characters.find(c => c.name === '김철용');
                    const hasChulyongProtection = chulyong && !chulyong.dead && gameState.truckDurability >= 50;
                    
                    // 부상 확률 계산 (폐허 붕괴 시 20%p 증가)
                    const injuryChance = gameState.ruinsInjuryIncreased ? 0.7 : 0.5;
                    
                    // 부상 체크 (김민지와 김철용의 보호 효과가 있는 경우 제외)
                    if (Math.random() < injuryChance && character.name !== '김민지' && !hasChulyongProtection) {
                        character.injured = true;
                        message += " 하지만 부상을 입었어.";
                    }
                    return message;
                }
            },
            blackmarket: {
                name: '암시장 보내기',
                description: '🍺술 1개를 소모해 🥩고기를 구한다.',
                isAvailable: (character) => !character.dead && !character.injured && gameState.resources.alcohol > 0,
                execute: (character) => {
                    let prefix = '';
                    if (character.happy) prefix = '(싱글벙글) ';
                    
                    // 이유원은 도박장으로 변경
                    if (character.name === '이유원') {
                        gameState.resources.alcohol -= 1;
                        const maxGain = character.happy ? 4 : 3; // 행복 상태일 때 최대 4개
                        const alcoholGained = Math.floor(Math.random() * (maxGain + 3)) - 2; // -2 ~ maxGain
                        
                        // 술이 음수가 되지 않도록 보정
                        if (alcoholGained < 0) {
                            gameState.resources.alcohol = Math.max(0, gameState.resources.alcohol + alcoholGained);
                        } else {
                            gameState.resources.alcohol += alcoholGained;
                        }
                        
                        let message = '';
                        if (alcoholGained < 0) {
                            if (character.happy) {
                                setHappy(character, false);
                                message = `${prefix}도박장에서 ${Math.abs(alcoholGained)}개를 잃고 도망치다가 총에 맞았어... 난 불행해...`;
                            } else {
                                message = `${prefix}도박장에서 ${Math.abs(alcoholGained)}개를 잃고 도망치다가 총에 맞았어...`;
                            }
                            character.injured = true;
                        } else if (alcoholGained === 0) {
                            if (character.happy) {
                                setHappy(character, false);
                                message = `${prefix}도박장에서 다 잃었어... 이제 안 행복해...`;
                            } else {
                                setDepressed(character, true);
                                message = `${prefix}도박장에서 다 잃었어... 우울해...`;
                            }
                        } else if (alcoholGained === 1) {
                            message = `${prefix}도박장에서 술 1개를 따왔어.`;
                        } else if (alcoholGained === 2) {
                            message = `${prefix}도박장에서 술 2개를 따왔어!`;
                        } else if (alcoholGained === 3) {
                            setHappy(character, true);
                            message = `${prefix}올인! 도박장에서 술 3개를 따왔어! 행복해!`;
                        } else {
                            message = `${prefix}도박장에서 술 4개를 따왔어!! 최고의 날이야!!`;
                        }
                        return message;
                    }
                    
                    // 다른 캐릭터들은 기존 암시장 로직
                    gameState.resources.alcohol -= 1;
                    let min = character.happy ? 3 : 2;
                    const meatFound = Math.floor(Math.random() * (6 - min + 1)) + min; // min~6
                    gameState.resources.meat += meatFound;
                    let message = `${prefix}암시장에 가서 술 1개를 고기 ${meatFound}개로 바꿔왔어.`;
                    // 50% 확률로 사기꾼을 만나 부상 (김민지는 제외)
                    if (Math.random() < 0.5 && character.name !== '김민지') {
                        if (character.happy) {
                            setHappy(character, false);
                            message += " 근데 거래 끝나고 뒤에서 총을 쏘더라고. 행복이 사라졌어...";
                        } else {
                            message += " 근데 거래 끝나고 뒤에서 총을 쏘더라고.";
                        }
                        character.injured = true;
                    }
                    return message;
                }
            },
            nurse: {
                name: '간호',
                description: '캠프에 있는 다른 모든 부상자의 부상을 회복시킨다.',
                isAvailable: (character) => {
                    // 캐릭터가 간호할 수 있는 상태인지 확인
                    if (character.dead || character.injured || character.depressed) return false;
                    
                    // 장재영은 간호할 수 없음
                    if (character.name === '장재영') return false;
                    
                    // 간호할 부상자가 있는지 확인
                    let hasInjured = false;
                    gameState.characters.forEach(c => {
                        if (c.id !== character.id && c.injured && !c.dead) {
                            hasInjured = true;
                        }
                    });
                    return hasInjured;
                },
                execute: (character) => {
                    let healedCharacters = [];
                    
                    gameState.characters.forEach(c => {
                        if (c.id !== character.id && c.injured && !c.dead) {
                            c.injured = false;
                            healedCharacters.push(c.name);
                        }
                    });
                    
                    let message = `부상당한 ${healedCharacters.join(', ')}를 간호했어.`;
                    
                    // 우원빈의 특수 능력: 2명 이상 간호 시 행복해짐
                    if (character.name === '우원빈' && healedCharacters.length >= 2) {
                        setHappy(character, true);
                        message += " 이렇게 많은 사람을 도울 수 있어서 행복해!";
                    }
                    
                    return message;
                }
            },
            rest: {
                name: '휴식',
                description: '자신의 우울이나 부상을 치료한다.',
                isAvailable: (character) => !character.dead && (character.depressed || character.injured),
                execute: (character) => {
                    let message = "";
                    
                    // 우울과 부상이 동시에 있는 경우
                    if (character.depressed && character.injured) {
                        // 랜덤으로 하나 선택
                        if (Math.random() < 0.5) {
                            setDepressed(character, false);
                            message = "휴식을 취해서 마음이 편안해졌어.";
                        } else {
                            setInjured(character, false);
                            message = "휴식을 취해서 부상이 나았어.";
                        }
                    } else if (character.depressed) {
                        // 우울만 있는 경우
                        setDepressed(character, false);
                        message = "휴식을 취해서 마음이 편안해졌어.";
                    } else if (character.injured) {
                        // 부상만 있는 경우
                        setInjured(character, false);
                        message = "휴식을 취해서 부상이 나았어.";
                    }
                    
                    return message;
                }
            },
            guard: {
                name: '경계',
                description: '캠프의 방어도를 올린다.',
                isAvailable: (character) => !character.dead && !character.injured && gameState.defense < 100,
                execute: (character) => {
                    let prefix = '';
                    let bonus = 0;
                    if (character.happy) {
                        prefix = '(싱글벙글) ';
                        bonus = 1;
                    }
                    let defenseIncrease = gameState.defenseFortification + bonus;
                    
                    // 최진영은 경계 효과 2배
                    if (character.name === '최진영') {
                        defenseIncrease *= 2;
                        // 경계 후 우울해짐
                        setDepressed(character, true);
                    }
                    
                    gameState.defense += defenseIncrease;
                    if (gameState.defense > 100) gameState.defense = 100;
                    
                    let message = `${prefix}경계를 서서 캠프의 방어도를 ${defenseIncrease}% 올렸어.`;
                    if (character.name === '최진영') {
                        message += " 난 진짜 괜찮아. 밤샜지만 진짜 괜찮아. 더 시켜줘.";
                    }
                    return message;
                }
            },
            party: {
                name: '파티 준비',
                description: '🍺술 1개를 소모해 밤에 있을 파티를 준비한다.',
                isAvailable: (character) => character.name === '차필근' && !character.dead && gameState.resources.alcohol > 0,
                execute: (character) => {
                    // 술 소모는 선택 시 처리
                    character.preparingParty = true;
                    return "오늘 밤 파티를 준비했어!";
                }
            },
            repair: {
                name: '트럭 수리',
                description: '트럭 내구도를 증가시킨다. 🔧부품을 쓸 수 있다.',
                isAvailable: (character) => !character.dead,
                execute: (character) => {
                    let prefix = '';
                    let bonus = 0;
                    if (character.happy) {
                        prefix = '(싱글벙글) ';
                        bonus = 1;
                    }
                    let repairAmount = 1 + bonus;
                    
                    // 서현은 수리 효과 2배 (기본 수리량과 부품 효과 모두 포함)
                    if (character.name === '신서현') {
                        repairAmount *= 2;
                    }  
                    let partMessage = '';
                    if (gameState.resources.parts > 0) {
                        repairAmount += gameState.resources.parts;
                        gameState.resources.parts -= 1;
                        partMessage = '부품으로 ';
                    }
                    gameState.truckDurability += repairAmount;
                    return `${prefix}${partMessage}트럭을 수리해서 내구도를 ${repairAmount}% 증가시켰어.`;
                }
            },
            build: {
                name: '건설',
                description: '🔧부품 1개를 소모해 방어시설을 건설한다.',
                isAvailable: (character) => !character.dead && gameState.resources.parts > 0,
                execute: (character) => {
                    // 부품 소모는 선택 시 처리
                    let defenseIncrease = 1;
                    
                    // 서현은 건설 효과 2배
                    if (character.name === '신서현') {
                        defenseIncrease *= 2;
                    }
                    
                    gameState.defenseFortification += defenseIncrease;
                    return `건설을 해서 앞으로 경계를 서면 방어도가 ${gameState.defenseFortification}% 올라가게 됐어.`;
                }
            },
            hipSurgery: {
                name: '고관절 개조',
                description: '🔧부품 3개를 소모해 고관절을 개조한다.',
                isAvailable: (character) => character.name === '김건희' && !character.dead && gameState.resources.parts >= 3 && !character.hasHipSurgery,
                execute: (character) => {
                    gameState.resources.parts -= 3;
                    character.trait = '고관절 사이보그';
                    character.hasHipSurgery = true;
                    return "고관절 개조가 완료됐어! 이제 아프지 않아.";
                }
            }
        };

        // DOM 요소 초기화
        function initializeDOM() {
            // 캐릭터 카드 생성
            const charactersContainer = document.getElementById('characters-container');
            charactersContainer.innerHTML = '';
            
            // 캐릭터 순서대로 카드 생성
            for (let i = 0; i < gameState.characters.length; i++) {
                const character = gameState.characters[i];
                const card = createCharacterCard(character);
                charactersContainer.appendChild(card);
            }
            
            // 턴 종료 버튼 이벤트
            document.getElementById('end-turn-button').addEventListener('click', endTurn);
            
            // 자원 패널 업데이트
            updateResourcePanel();
            
            // 트럭 및 방어도 업데이트
            updateGameStatus();
        }

        // 캐릭터 카드 생성
        function createCharacterCard(character) {
            const card = document.createElement('div');
            card.className = `character-card ${character.dead ? 'dead' : ''}`;
            card.id = `character-${character.id}`;
            
            const actionName = character.action ? actions[character.action].name : '';
            
            card.innerHTML = `
                <div class="character-name">
                    <span>${character.name}</span>
                    ${actionName ? `<span class="selected-action">${actionName}</span>` : ''}
                </div>
                <div class="character-trait">${character.trait}</div>
                <div class="status-labels" id="status-${character.id}">
                    ${character.injured ? '<span class="status-label injured">부상</span>' : ''}
                    ${character.depressed ? '<span class="status-label depressed">우울</span>' : ''}
                    ${character.happy ? '<span class="status-label" style="background-color:var(--success-color);color:black;">행복</span>' : ''}
                    ${character.dead ? '<span class="status-label dead">사망</span>' : ''}
                </div>
                <div class="actions-container" id="actions-${character.id}">
                    <!-- 행동 버튼들이 JavaScript로 동적 생성됩니다 -->
                </div>
            `;
            
            // 캐릭터가 죽었으면 행동 비활성화
            if (!character.dead) {
                const actionsContainer = card.querySelector(`#actions-${character.id}`);
                
                // 가능한 행동들 표시
                Object.keys(actions).forEach(actionKey => {
                    const action = actions[actionKey];
                    
                    // 해당 캐릭터가 할 수 있는 행동인지 확인
                    if (action.isAvailable(character)) {
                        const button = document.createElement('button');
                        button.className = 'action-button';
                        button.textContent = character.name === '이유원' && actionKey === 'blackmarket' ? '도박장 보내기' : action.name;
                        button.dataset.action = actionKey;
                        button.disabled = character.action !== null;
                        
                        // 툴팁 추가
                        const tooltip = document.createElement('div');
                        tooltip.className = 'action-tooltip';
                        tooltip.textContent = character.name === '이유원' && actionKey === 'blackmarket' ? 
                            '🍺술을 걸고 도박을 한다.' : 
                            action.description;
                        
                        // 툴팁 위치 업데이트 함수
                        const updateTooltipPosition = (e) => {
                            const rect = button.getBoundingClientRect();
                            tooltip.style.left = `${rect.left + (rect.width / 2)}px`;
                            tooltip.style.top = `${rect.top - tooltip.offsetHeight - 10}px`;
                        };
                        
                        // 툴팁을 body에 추가
                        document.body.appendChild(tooltip);
                        
                        // 호버 이벤트
                        button.addEventListener('mouseenter', (e) => {
                            updateTooltipPosition(e);
                            tooltip.style.display = 'block';
                        });
                        
                        button.addEventListener('mouseleave', () => {
                            tooltip.style.display = 'none';
                        });
                        
                        // 클릭 이벤트
                        button.addEventListener('click', () => {
                            selectAction(character, actionKey);
                        });
                        
                        actionsContainer.appendChild(button);
                    }
                });
            }
            
            return card;
        }

        // 행동 선택
        function selectAction(character, actionKey) {
            console.log(`Selecting action ${actionKey} for ${character.name}`); // 디버깅용
            
            // 행동이 유효한지 확인
            if (!actions[actionKey]) {
                console.error(`Invalid action key: ${actionKey}`);
                return;
            }
            
            // 행동이 가능한지 확인
            if (!actions[actionKey].isAvailable(character)) {
                console.error(`Action ${actionKey} is not available for ${character.name}`);
                return;
            }
            
            character.action = actionKey;
            console.log(`Action set for ${character.name}: ${actionKey}`); // 디버깅용
            
            // 파티 준비나 건설처럼 자원을 소모하는 행동은 선택 즉시 자원 차감
            if (actionKey === 'party') {
                if (gameState.resources.alcohol > 0) {
                    gameState.resources.alcohol -= 1;
                }
            }
            if (actionKey === 'build') {
                if (gameState.resources.parts > 0) {
                    gameState.resources.parts -= 1;
                }
            }
            
            // 선택된 버튼 표시
            const actionsContainer = document.querySelector(`#actions-${character.id}`);
            const buttons = actionsContainer.querySelectorAll('.action-button');
            buttons.forEach(button => {
                button.disabled = true;
                if (button.dataset.action === actionKey) {
                    button.classList.add('selected');
                }
            });
            
            // 턴 종료 버튼 활성화 여부 체크
            checkEndTurnButton();
            
            // 자원 패널 즉시 갱신
            updateResourcePanel();
        }

        // 턴 종료 버튼 활성화 여부 체크
        function checkEndTurnButton() {
            const endTurnButton = document.getElementById('end-turn-button');
            
            // 살아있는 모든 캐릭터가 행동을 선택했는지 확인
            const allSelected = gameState.characters.every(character => 
                character.dead || character.action !== null
            );
            
            endTurnButton.disabled = !allSelected;
        }

        // 턴 종료
        function endTurn() {
            gameState.isNight = true;
            document.getElementById('time-period').textContent = '밤';
            
            // 행동 결과를 저장할 임시 배열
            const actionResults = [];
            // 굶주림 메시지를 저장할 임시 배열
            const foodMessages = [];
            
            // 각 캐릭터의 행동 결과 처리 (순서대로)
            for (let i = 0; i < gameState.characters.length; i++) {
                const character = gameState.characters[i];
                if (!character.dead && character.action !== null) {
                    const action = actions[character.action];
                    if (action && typeof action.execute === 'function') {
                        try {
                            const result = action.execute(character);
                            if (result && typeof result === 'string') {
                                actionResults.push(`${character.name}: ${result}`);
                            }
                        } catch (error) {
                            console.error(`Error executing action for ${character.name}:`, error);
                        }
                    }
                }
                // 행동 초기화
                character.action = null;
            }
            
            // 식량 소비 (foodMessages 배열을 인자로 받음)
            consumeFood(foodMessages);
            
            // 밤 이벤트 메시지 초기화
            gameState.nightMessages = [];
            gameState.currentMessageIndex = 0;
            
            // 행동 결과, 굶주림 메시지 추가
            gameState.nightMessages = [...actionResults, ...foodMessages];
            
            // 방어도 하락 (50% 확률로 5% 하락)
            if (Math.random() < 0.5) {
                gameState.defense -= 5;
                if (gameState.defense < 0) gameState.defense = 0;
                // 살아있는 캐릭터 중 랜덤으로 한 명 선택
                const livingCharacters = gameState.characters.filter(c => !c.dead);
                if (livingCharacters.length > 0) {
                    const randomIndex = Math.floor(Math.random() * livingCharacters.length);
                    const warningCharacter = livingCharacters[randomIndex];
                    gameState.nightMessages.push(`${warningCharacter.name}: 캠프 주변이 어수선해. 방어도가 5% 감소했어.`);
                }
            }
            
            // 밤 이벤트 체크
            checkNightEvents();
            
            // 다음 턴 준비
            updateResourcePanel();
            updateGameStatus();
            
            // 메시지 로그에 날짜 추가
            addToMessageLog(`===== ${gameState.day}일차 밤 =====`);
            
            // 밤 이벤트 모달 시작
            startNightEvents();
        }

        // 식량 소비 (foodMessages 배열을 인자로 받음)
        function consumeFood(foodMessages) {
            for (let i = 0; i < gameState.characters.length; i++) {
                const character = gameState.characters[i];
                if (!character.dead) {
                    // 오성국은 식량 2개 소비
                    const neededFood = character.name === '오성국' ? 2 : 1;
                    let hasEaten = false;

                    if (character.name === '정윤지') {
                        // 윤지는 야채만 먹음
                        if (gameState.resources.vegetables >= neededFood) {
                            gameState.resources.vegetables -= neededFood;
                            hasEaten = true;
                        }
                    } else {
                        // 다른 캐릭터들은 고기 우선, 부족하면 야채
                        if (gameState.resources.meat >= neededFood) {
                            gameState.resources.meat -= neededFood;
                            hasEaten = true;
                        } else if (gameState.resources.vegetables >= neededFood) {
                            gameState.resources.vegetables -= neededFood;
                            hasEaten = true;
                        } else if (gameState.resources.meat + gameState.resources.vegetables >= neededFood) {
                            // 혼합 식량
                            const usedMeat = Math.min(gameState.resources.meat, neededFood);
                            gameState.resources.meat -= usedMeat;
                            gameState.resources.vegetables -= (neededFood - usedMeat);
                            hasEaten = true;
                        }
                    }

                    // 식량을 먹지 못했다면 반드시 대사 출력
                    if (!hasEaten) {
                        if (character.name === '정윤지') {
                            foodMessages.push(`${character.name}: 야채 아니면 안 먹을래...`);
                        } else {
                            foodMessages.push(`${character.name}: 식량이 부족해서 굶었어...`);
                        }
                        makeDepressed(character, foodMessages);
                    }
                }
            }
        }

        // 캐릭터 상태 변경 함수들
        function setDepressed(character, value) {
            if (value === true) {
                // 우울해질 때 행복 상태를 먼저 제거
                character.happy = false;
            }
            character.depressed = value;
        }
        
        function setHappy(character, value) {
            if (value === true) {
                // 행복해질 때 우울 상태를 먼저 제거
                character.depressed = false;
            }
            character.happy = value;
        }
        
        function setInjured(character, value) {
            character.injured = value;
        }

        // 캐릭터 우울하게 만듦
        function makeDepressed(character, msgArray) {
            if (character.happy) {
                setHappy(character, false);
                msgArray.push(`${character.name}: 이제 안 행복해...`);
                return;
            }
            
            if (!character.depressed) {
                setDepressed(character, true);
                msgArray.push(`${character.name}: 우울해졌어...`);
            } else {
                character.dead = true;
                msgArray.push(`${character.name}: 미안, 친구들. 나 같은 쓰레기가 살아서 뭐하겠어. 잘 있어.`);
                handleCharacterDeath();
            }
        }

        // 캐릭터 부상 입힘
        function makeInjured(character) {
            if (character.happy) {
                setHappy(character, false);
                gameState.nightMessages.push(`${character.name}: 행복이 사라졌어...`);
            }
            
            // 김건희의 고관절 메시지 먼저 출력
            if (character.name === '김건희' && !character.hasHipSurgery) {
                gameState.nightMessages.push(`${character.name}: 아... 고관절이 또...`);
            }
            
            if (!character.injured) {
                setInjured(character, true);
                gameState.nightMessages.push(`${character.name}: 부상을 입었어...`);
                
                // 장재영이 살아있으면 50% 확률로 행복해짐
                const jaeyoung = gameState.characters.find(c => c.name === '장재영');
                if (jaeyoung && !jaeyoung.dead && Math.random() < 0.1) {
                    setHappy(jaeyoung, true);
                    gameState.nightMessages.push(`${jaeyoung.name}: 흐흐... 재밌다!`);
                }
            } else {
                character.dead = true;
                gameState.nightMessages.push(`${character.name}: 커헉! (피 토하는 소리)`);
                handleCharacterDeath();
            }
        }

        // 캐릭터 사망 처리
        function handleCharacterDeath() {
            // 다른 캐릭터들 50% 확률로 우울
            const recentlyDeadCharacters = gameState.characters.filter(c => c.dead && !c.wasProcessed);
            if (recentlyDeadCharacters.length > 0) {
                // 가장 최근에 죽은 캐릭터 선택
                const deadCharacter = recentlyDeadCharacters[recentlyDeadCharacters.length - 1];
                deadCharacter.wasProcessed = true; // 이미 언급된 캐릭터 표시
                
                // 각 캐릭터별로 50% 확률로 우울 반응 (장재영 제외)
                gameState.characters.forEach(character => {
                    if (!character.dead && character.name !== '장재영' && Math.random() < 0.5) {
                        if (!character.depressed) {
                            setDepressed(character, true);
                            gameState.nightMessages.push(`${character.name}: ${deadCharacter.name}이가 죽다니...`);
                        }
                    }
                });
            }
            
            // 게임 오버 체크
            checkGameOver();
        }

        // 밤 이벤트 체크
        function checkNightEvents() {
            // 김건희의 밤 부상 체크
            const geonhee = gameState.characters.find(c => c.name === '김건희');
            if (geonhee && !geonhee.dead && !geonhee.hasHipSurgery && Math.random() < 0.5) {
                makeInjured(geonhee);
            }

            // 양건수의 고백 체크
            const gunsoo = gameState.characters.find(c => c.name === '양건수');
            if (gunsoo && !gunsoo.dead && Math.random() < 0.15) {
                // 살아있는 다른 캐릭터들 중에서 랜덤 선택
                const livingCharacters = gameState.characters.filter(c => !c.dead && c.name !== '양건수');
                if (livingCharacters.length > 0) {
                    const target = livingCharacters[Math.floor(Math.random() * livingCharacters.length)];
                    
                    // 고백 메시지
                    gameState.nightMessages.push(`${gunsoo.name}: ${target.name} 씨... 제 마음을 받아주세요...`);
                    
                    // 50% 확률로 거절당함
                    if (Math.random() < 0.5) {
                        gameState.nightMessages.push(`${target.name}: 으으... 그만...`);
                        setDepressed(target, true);
                        gameState.nightMessages.push(`${target.name}: 우울해...`);
                    } else {
                        setDepressed(gunsoo, true);
                        gameState.nightMessages.push(`${gunsoo.name}: 힝...`);
                    }
                }
            }

            // 습격 체크 (방어도의 확률로 습격 없음)
            if (Math.random() > gameState.defense / 100) {
                // 습격 발생
                gameState.nightMessages.push("갱단이 습격해왔다!");
                
                // 지오원이 살아있으면 15% 확률로 격퇴
                const jiwon = gameState.characters.find(c => c.name === '홍지원');
                if (jiwon && !jiwon.dead && Math.random() < 0.15) {
                    gameState.nightMessages.push("홍지원: 망고, 물어!");
                    gameState.nightMessages.push("망고: 왕왕!");
                    gameState.nightMessages.push("갱단이 겁에 질려 도망갔다!");
                    
                    // 예삐가 살아있으면 감탄
                    const yebbi = gameState.characters.find(c => c.name === '예삐');
                    if (yebbi && !yebbi.dead) {
                        gameState.nightMessages.push("예삐: 훌륭한 사냥개로군!");
                    }
                } else {
                    // 습격이 없었을 때 술 먹어치우기 이벤트 체크
                    if (gameState.resources.alcohol > 0) {
                        const depressedCharacters = gameState.characters.filter(c => !c.dead && c.depressed);
                        if (depressedCharacters.length > 0) {
                            const drinker = depressedCharacters[Math.floor(Math.random() * depressedCharacters.length)];
                            gameState.resources.alcohol -= 1;
                            gameState.nightMessages.push(`${drinker.name}: (술병을 들고) 우울한데 이거라도 먹자...`);
                            
                            // 15% 확률로 우울함이 낫음
                            if (Math.random() < 0.15) {
                                setDepressed(drinker, false);
                                gameState.nightMessages.push(`${drinker.name}: 음... 기분이 좀 나아졌어.`);
                            } else {
                                gameState.nightMessages.push(`${drinker.name}: (벌컥벌컥) 흐음... 그래도 우울해...`);
                            }
                        }
                    }
                    
                    // 우울한 캐릭터들 사이의 싸움 이벤트 체크
                    const depressedCharacters = gameState.characters.filter(c => !c.dead && c.depressed && !c.injured);
                    if (depressedCharacters.length >= 2) {
                        // 랜덤하게 2명 선택
                        const shuffled = [...depressedCharacters].sort(() => 0.5 - Math.random());
                        const fighter1 = shuffled[0];
                        const fighter2 = shuffled[1];
                        
                        gameState.nightMessages.push(`${fighter1.name}: 야, ${fighter2.name}. 너 왜 눈을 그렇게 떠?`);
                        gameState.nightMessages.push(`${fighter2.name}: 뭐래? 맞을래?`);
                        gameState.nightMessages.push(`${fighter1.name}와 ${fighter2.name}가 다퉜습니다. 둘 다 부상을 입었습니다.`);
                        
                        // 둘 다 부상 입음
                        setInjured(fighter1, true);
                        setInjured(fighter2, true);
                    }
                    
                    // 파티 준비했고 습격이 없었음
                    const pilgeun = gameState.characters.find(c => c.name === '차필근');
                    if (pilgeun?.preparingParty) {
                        gameState.nightMessages.push("파티는 취소됐다!");
                        pilgeun.preparingParty = false;
                    }
                    
                    // 살아있는 사람 중 한 명 부상
                    const livingCharacters = gameState.characters.filter(c => !c.dead);
                    if (livingCharacters.length > 0) {
                        const victimIndex = Math.floor(Math.random() * livingCharacters.length);
                        const victim = livingCharacters[victimIndex];
                        makeInjured(victim);
                    }
                    // 방어도가 낮을수록 트럭 공격 확률 증가
                    if (Math.random() > gameState.defense / 100) {
                        const damage = Math.floor(Math.random() * 10) + 1; // 1-10 데미지
                        gameState.truckDurability -= damage;
                        
                        // 랜덤 생존자가 트럭 공격 상황 보고
                        const livingChars = gameState.characters.filter(c => !c.dead);
                        if (livingChars.length > 0) {z
                            const reporter = livingChars[Math.floor(Math.random() * livingChars.length)];
                            gameState.nightMessages.push(`${reporter.name}: 놈들이 트럭까지 공격했어!`);
                        }
                    }
                }
            } else {
                // 습격이 없었을 때 술 먹어치우기 이벤트 체크
                if (gameState.resources.alcohol > 0) {
                    const depressedCharacters = gameState.characters.filter(c => !c.dead && c.depressed);
                    if (depressedCharacters.length > 0) {
                        const drinker = depressedCharacters[Math.floor(Math.random() * depressedCharacters.length)];
                        gameState.resources.alcohol -= 1;
                        gameState.nightMessages.push(`${drinker.name}: (술병을 들고) 이거라도 있지...`);
                        
                        // 15% 확률로 우울함이 낫음
                        if (Math.random() < 0.15) {
                            setDepressed(drinker, false);
                            gameState.nightMessages.push(`${drinker.name}: 음... 술이 생각보다 맛있네. 기분이 좀 나아졌어.`);
                        } else {
                            gameState.nightMessages.push(`${drinker.name}: (술병을 비우고) 흐음... 그래도 우울해...`);
                        }
                    }
                }
                
                // 우울한 캐릭터들 사이의 싸움 이벤트 체크
                const depressedCharacters = gameState.characters.filter(c => !c.dead && c.depressed && !c.injured);
                if (depressedCharacters.length >= 2) {
                    // 랜덤하게 2명 선택
                    const shuffled = [...depressedCharacters].sort(() => 0.5 - Math.random());
                    const fighter1 = shuffled[0];
                    const fighter2 = shuffled[1];
                    
                    gameState.nightMessages.push(`${fighter1.name}: 야, ${fighter2.name}. 너 왜 눈을 그렇게 떠?`);
                    gameState.nightMessages.push(`${fighter2.name}: 뭐래? 맞을래?`);
                    gameState.nightMessages.push(`${fighter1.name}와 ${fighter2.name}가 다퉜습니다. 부상을 입었습니다.`);
                    
                    // 둘 다 부상 입음
                    setInjured(fighter1, true);
                    setInjured(fighter2, true);
                }
                
                // 파티 준비했고 습격이 없었음
                const pilgeun = gameState.characters.find(c => c.name === '차필근');
                if (pilgeun?.preparingParty) {
                    gameState.nightMessages.push("차필근이 준비했다는 파티가 시작됐다!");
                    
                    // 랜덤하게 3개의 대사 중 하나 선택
                    const partyMessages = [
                        "차필근: 다같이 우리 반지하의 미래를 스케치북에 그려볼까요?",
                        "차필근: 제가 피아노를 연주해드릴게요! (딩딩딩)",
                        "차필근: (열창하며) 압둘바~ 압둘바~ 압둘바~"
                    ];
                    const randomMessage = partyMessages[Math.floor(Math.random() * partyMessages.length)];
                    gameState.nightMessages.push(randomMessage);
                    
                    // 김세협의 시 창작 (파티 중에는 100% 발동)
                    const seohyeop = gameState.characters.find(c => c.name === '김세협');
                    if (seohyeop && !seohyeop.dead) {
                        const partyPoems = [
                            "우리의 파티는 별빛처럼 빛나고,\n모든 어둠을 밝혀주는 희망의 빛이 되어주네.",
                            "이 순간 우리는 하나가 되어,\n서로의 마음을 나누며 행복을 나누네.",
                            "파티의 기쁨이 우리를 감싸고,\n모든 걱정과 근심을 잊게 해주네."
                        ];
                        const poem = partyPoems[Math.floor(Math.random() * partyPoems.length)];
                        gameState.nightMessages.push(`김세협: ${poem}`);
                        
                        // 랜덤 생존자 한 명의 우울 회복 또는 행복 부여
                        const living = gameState.characters.filter(c => !c.dead && c.name !== '김세협');
                        if (living.length > 0) {
                            const target = living[Math.floor(Math.random() * living.length)];
                            if (target.depressed) {
                                setDepressed(target, false);
                                gameState.nightMessages.push(`${target.name}: 시를 듣고 마음이 편안해졌어...`);
                            } else {
                                setHappy(target, true);
                                gameState.nightMessages.push(`${target.name}: 시를 듣고 행복해졌어!`);
                            }
                        }
                    }
                    
                    // 모든 캐릭터의 우울 회복
                    gameState.characters.forEach(character => {
                        if (!character.dead && character.depressed) {
                            setDepressed(character, false);
                            gameState.nightMessages.push(`${character.name}: 우울함이 사라졌어!`);
                        }
                    });
                    // 파티 성공 시 랜덤 생존자 1명에게 행복 부여
                    const living = gameState.characters.filter(c => !c.dead);
                    if (living.length > 0) {
                        const lucky = living[Math.floor(Math.random() * living.length)];
                        setHappy(lucky, true);
                        gameState.nightMessages.push(`${lucky.name}: ${lucky.name} 행복해! 뭐든지 해낼 수 있을 것만 같아!`);
                    }
                } else {
                    // 습격이 없었고 파티도 없었을 때 김세협의 시 창작 (15% 확률)
                    const seohyeop = gameState.characters.find(c => c.name === '김세협');
                    if (seohyeop && !seohyeop.dead && Math.random() < 0.15) {
                        if (seohyeop.depressed) {
                            // 우울한 상태의 시
                            const darkPoems = [
                                "희망이 부족해...\n이 세상은 우리를 조금씩 먹어치우고 있어.",
                                "생존은 허상일 뿐이야...\n우리는 결국 모두 죽음을 맞이할 거야.",
                                "이 지옥 속에서 우리는...\n점점 더 깊은 절망으로 빠져들고 있어."
                            ];
                            const poem = darkPoems[Math.floor(Math.random() * darkPoems.length)];
                            gameState.nightMessages.push(`김세협: ${poem}`);
                            
                            // 랜덤 생존자 한 명의 행복 제거 또는 우울 부여
                            const living = gameState.characters.filter(c => !c.dead && c.name !== '김세협');
                            if (living.length > 0) {
                                const target = living[Math.floor(Math.random() * living.length)];
                                if (target.happy) {
                                    setHappy(target, false);
                                    gameState.nightMessages.push(`${target.name}: 시를 듣고 행복이 사라졌어...`);
                                } else {
                                    setDepressed(target, true);
                                    gameState.nightMessages.push(`${target.name}: 시를 듣고 죽고 싶어졌어...`);
                                }
                            }
                        } else {
                            // 일반 상태의 시
                            const normalPoems = [
                                "이 밤하늘의 별들이,\n우리의 미래를 비추고 있어.",
                                "폐허 속에서도 우리는,\n새로운 희망을 찾아내고 있어.",
                                "서로를 믿고 의지하며,\n우리는 더 강해질 수 있어."
                            ];
                            const poem = normalPoems[Math.floor(Math.random() * normalPoems.length)];
                            gameState.nightMessages.push(`김세협: ${poem}`);
                            
                            // 랜덤 생존자 한 명의 우울 회복 또는 행복 부여
                            const living = gameState.characters.filter(c => !c.dead && c.name !== '김세협');
                            if (living.length > 0) {
                                const target = living[Math.floor(Math.random() * living.length)];
                                if (target.depressed) {
                                    setDepressed(target, false);
                                    gameState.nightMessages.push(`${target.name}: 시를 듣고 마음이 편안해졌어...`);
                                } else {
                                    setHappy(target, true);
                                    gameState.nightMessages.push(`${target.name}: 시를 듣고 행복해졌어!`);
                                }
                            }
                        }
                    }
                }
            }
            
            // 파티 준비 상태 초기화
            const pilgeun = gameState.characters.find(c => c.name === '차필근');
            if (pilgeun) {
                pilgeun.preparingParty = false;
            }
        }

        // 밤 이벤트 시작
        function startNightEvents() {
            if (gameState.nightMessages.length > 0) {
                const modal = document.getElementById('night-events-modal');
                const message = document.getElementById('night-event-message');
                const continueButton = document.getElementById('continue-night-button');
                
                // 메시지 표시
                message.textContent = gameState.nightMessages[gameState.currentMessageIndex];
                modal.style.display = 'flex';
                
                // 계속 버튼 이벤트 설정
                continueButton.onclick = function() {
                    console.log(`Current message index: ${gameState.currentMessageIndex}`); // 디버깅용
                    console.log(`Total messages: ${gameState.nightMessages.length}`); // 디버깅용
                    
                    gameState.currentMessageIndex++;
                    
                    if (gameState.currentMessageIndex < gameState.nightMessages.length) {
                        console.log(`Showing message: ${gameState.nightMessages[gameState.currentMessageIndex]}`); // 디버깅용
                        message.textContent = gameState.nightMessages[gameState.currentMessageIndex];
                    } else {
                        console.log('All messages shown, moving to next day'); // 디버깅용
                        modal.style.display = 'none';
                        gameState.currentMessageIndex = 0; // 인덱스 초기화
                        goToNextDay();
                    }
                };
            } else {
                goToNextDay();
            }
        }

        // 다음 날로
        function goToNextDay() {
            gameState.day++;
            gameState.isNight = false;
            document.getElementById('time-period').textContent = '낮';
            
            // 메시지 로그에 날짜 추가
            addToMessageLog(`===== ${gameState.day}일차 낮 =====`);
            
            // 15일, 30일, 45일 특별 이벤트 체크
            if (gameState.day === 15 || gameState.day === 30 || gameState.day === 45) {
                const livingCharacters = gameState.characters.filter(c => !c.dead);
                if (livingCharacters.length > 0) {
                    const randomCharacter = livingCharacters[Math.floor(Math.random() * livingCharacters.length)];
                    
                    // 아직 발생하지 않은 위기 중에서 랜덤 선택
                    const availableCrises = [];
                    if (!gameState.forestCrisis) availableCrises.push('forest');
                    if (!gameState.ruinsCrisis) availableCrises.push('ruins');
                    if (!gameState.gangCrisis) availableCrises.push('gang');
                    
                    if (availableCrises.length > 0) {
                        const selectedCrisis = availableCrises[Math.floor(Math.random() * availableCrises.length)];
                        
                        switch(selectedCrisis) {
                            case 'forest':
                                addToMessageLog(`${randomCharacter.name}: 숲의 자원이 고갈되고 있어!`);
                                gameState.forestCrisis = true;
                                break;
                            case 'ruins':
                                addToMessageLog(`${randomCharacter.name}: 폐허가 붕괴하고 있어!`);
                                gameState.ruinsCrisis = true;
                                break;
                            case 'gang':
                                addToMessageLog(`${randomCharacter.name}: 갱단이 더 공격적으로 변하고 있어!`);
                                gameState.defense -= 5;
                                if (gameState.defense < 0) gameState.defense = 0;
                                updateGameStatus();
                                gameState.gangCrisis = true;
                                break;
                        }
                    }
                }
            }
            
            // 식량 부족 체크
            const totalMeat = gameState.resources.meat;
            const totalVegetables = gameState.resources.vegetables;
            
            // 필요한 식량 계산 (기본적으로 생존자 1명당 1개씩)
            let requiredFood = 0;
            gameState.characters.forEach(character => {
                if (!character.dead) {
                    // 오성국은 식량을 2개 소비
                    requiredFood += (character.name === '오성국' ? 2 : 1);
                }
            });
            
            // 식량 부족 경고
            if (totalMeat + totalVegetables < requiredFood) {
                // 살아있는 캐릭터 중 랜덤으로 한 명 선택
                const livingCharacters = gameState.characters.filter(c => !c.dead);
                if (livingCharacters.length > 0) {
                    const randomIndex = Math.floor(Math.random() * livingCharacters.length);
                    const warningCharacter = livingCharacters[randomIndex];
                    addToMessageLog(`${warningCharacter.name}: 식량이 부족해. 이러다 굶겠어.`);
                }
            }
            
            // 캐릭터 업데이트
            gameState.characters.forEach(character => {
                const card = document.getElementById(`character-${character.id}`);
                if (character.dead) {
                    card.classList.add('dead');
                } else {
                    // 상태 라벨 업데이트
                    const statusContainer = document.getElementById(`status-${character.id}`);
                    statusContainer.innerHTML = '';
                    if (character.injured) {
                        const label = document.createElement('span');
                        label.className = 'status-label injured';
                        label.textContent = '부상';
                        statusContainer.appendChild(label);
                    }
                    if (character.depressed) {
                        const label = document.createElement('span');
                        label.className = 'status-label depressed';
                        label.textContent = '우울';
                        statusContainer.appendChild(label);
                    }
                    if (character.happy) {
                        const label = document.createElement('span');
                        label.className = 'status-label';
                        label.style.backgroundColor = 'var(--success-color)';
                        label.style.color = 'black';
                        label.textContent = '행복';
                        statusContainer.appendChild(label);
                    }
                }
            });
            
            // 행동 버튼 초기화
            initializeDOM();
            
            // 게임 클리어 체크
            if (gameState.truckDurability >= 100) {
                endGame(true);
            }
        }

        // 게임 오버 체크
        function checkGameOver() {
            const allDead = gameState.characters.every(character => character.dead);
            if (allDead) {
                endGame(false);
            }
        }

        // 게임 종료
        function endGame(victory) {
            const modal = document.getElementById('game-over-modal');
            const title = document.getElementById('modal-title');
            const message = document.getElementById('modal-message');
            
            if (victory) {
                title.textContent = '탈출!';
                
                // 생존자 수 확인 및 랭크 부여
                const survivors = gameState.characters.filter(character => !character.dead);
                const survivorNames = survivors.map(character => character.name).join(', ');
                let rank = '';
                
                if (survivors.length === 4) {
                    rank = 'S';
                } else if (survivors.length === 3) {
                    rank = 'A';
                } else if (survivors.length === 2) {
                    rank = 'B';
                } else if (survivors.length === 1) {
                    rank = 'C';
                }
                
                message.textContent = `${gameState.day}일 만에 위험 지역을 탈출했습니다. 
생존자: ${survivorNames} (${rank}랭크)`;
            } else {
                title.textContent = '패배...';
                message.textContent = '모든 생존자가 죽었습니다...';
            }
            
            modal.style.display = 'flex';
        }

        // 게임 재시작
        function restartGame() {
            location.reload();
        }

        // 자원 패널 업데이트
        function updateResourcePanel() {
            document.getElementById('meat-value').textContent = gameState.resources.meat;
            document.getElementById('vegetables-value').textContent = gameState.resources.vegetables;
            document.getElementById('parts-value').textContent = gameState.resources.parts;
            document.getElementById('alcohol-value').textContent = gameState.resources.alcohol;
            
            // 자원이 변경될 때마다 버튼 상태 업데이트
            updateActionButtons();
        }

        // 게임 상태 업데이트
        function updateGameStatus() {
            document.getElementById('day-value').textContent = gameState.day;
            document.getElementById('truck-value').textContent = `${gameState.truckDurability}%`;
            document.getElementById('defense-value').textContent = `${gameState.defense}%`;
            
            document.getElementById('truck-bar').style.width = `${gameState.truckDurability}%`;
            document.getElementById('defense-bar').style.width = `${gameState.defense}%`;
        }

        // 메시지 로그에 추가
        function addToMessageLog(message) {
            const messageLog = document.getElementById('message-log');
            const messageElement = document.createElement('div');
            messageElement.className = 'message';
            messageElement.textContent = message;
            messageLog.appendChild(messageElement);
            messageLog.scrollTop = messageLog.scrollHeight;
        }

        // 캐릭터 선택 모달 초기화
        function initializeCharacterSelect() {
            const grid = document.getElementById('character-select-grid');
            grid.innerHTML = '';
            
            Object.values(allCharacters).forEach(character => {
                const button = document.createElement('div');
                button.className = 'character-select-button';
                button.dataset.characterId = character.id;
                
                button.innerHTML = `
                    <div class="character-name">${character.name} <span class="character-points">(${character.points}pt)</span></div>
                    <div class="character-trait">${character.trait}</div>
                    <div class="trait-tooltip">${character.description}</div>
                `;
                
                button.addEventListener('click', () => toggleCharacterSelection(character.id));
                grid.appendChild(button);
            });
            
            // 게임 시작 버튼 이벤트
            document.getElementById('start-game-button').addEventListener('click', startGameWithSelectedCharacters);
            
            // 초기 포인트 설정
            gameState.remainingPoints = 4;
            updateSelectedCount();
            updateCharacterSelectButtons();
        }

        // 캐릭터 선택 토글
        function toggleCharacterSelection(characterId) {
            const button = document.querySelector(`[data-character-id="${characterId}"]`);
            const isSelected = button.classList.contains('selected');
            const selectedCount = document.querySelectorAll('.character-select-button.selected').length;
            const character = allCharacters[characterId];
            
            if (isSelected) {
                button.classList.remove('selected');
                button.dataset.selectionOrder = '';  // 선택 순서 제거
                gameState.remainingPoints += character.points;
            } else if (selectedCount < 4 && gameState.remainingPoints - character.points >= 0) {
                button.classList.add('selected');
                button.dataset.selectionOrder = selectedCount + 1;  // 선택 순서 저장
                gameState.remainingPoints -= character.points;
            }
            
            // 포인트가 변경될 때마다 버튼 상태 업데이트
            updateSelectedCount();
            updateCharacterSelectButtons();
        }

        // 선택된 캐릭터 수 업데이트
        function updateSelectedCount() {
            const selectedCount = document.querySelectorAll('.character-select-button.selected').length;
            document.getElementById('selected-count').textContent = selectedCount;
            document.getElementById('remaining-points').textContent = gameState.remainingPoints;
            document.getElementById('start-game-button').disabled = selectedCount !== 4;
        }

        // 캐릭터 선택 버튼 상태 업데이트
        function updateCharacterSelectButtons() {
            const buttons = document.querySelectorAll('.character-select-button');
            const selectedCount = document.querySelectorAll('.character-select-button.selected').length;
            
            buttons.forEach(button => {
                const characterId = button.dataset.characterId;
                const character = allCharacters[characterId];
                const isSelected = button.classList.contains('selected');
                
                // 이미 선택된 캐릭터는 비활성화하지 않음
                if (isSelected) {
                    button.classList.remove('disabled');
                    return;
                }
                
                // 선택할 수 없는 조건 체크
                const cannotSelect = selectedCount >= 4 || gameState.remainingPoints - character.points < 0;
                
                // 버튼 상태 업데이트
                if (cannotSelect) {
                    button.classList.add('disabled');
                } else {
                    button.classList.remove('disabled');
                }
            });
        }

        // 선택된 캐릭터로 게임 시작
        function startGameWithSelectedCharacters() {
            const selectedButtons = Array.from(document.querySelectorAll('.character-select-button.selected'))
                .sort((a, b) => parseInt(a.dataset.selectionOrder) - parseInt(b.dataset.selectionOrder));
            const selectedCharacters = [];
            
            // 선택된 버튼들을 순서대로 처리
            for (let i = 0; i < selectedButtons.length; i++) {
                const button = selectedButtons[i];
                const characterId = button.dataset.characterId;
                const character = allCharacters[characterId];
                selectedCharacters.push({
                    id: character.id,
                    name: character.name,
                    trait: character.trait,
                    action: null,
                    injured: false,
                    depressed: false,
                    dead: false,
                    happy: false
                });
            }
            
            // 게임 상태 초기화
            gameState.characters = selectedCharacters;
            
            // 남은 포인트를 고기로 교환
            if (gameState.remainingPoints > 0) {
                const meatGained = gameState.remainingPoints * 4;
                gameState.resources.meat += meatGained;
                
                // 이벤트 모달 표시
                const modal = document.getElementById('night-events-modal');
                const message = document.getElementById('night-event-message');
                message.textContent = `남은 ${gameState.remainingPoints}pt는 고기 ${meatGained}개로 교환해드렸습니다.`;
                modal.style.display = 'flex';
                
                // 계속 버튼 클릭 시 게임 시작
                const continueButton = document.getElementById('continue-night-button');
                continueButton.onclick = function() {
                    modal.style.display = 'none';
                    document.getElementById('character-select-modal').style.display = 'none';
                    initializeDOM();
                };
            } else {
                // 포인트가 없으면 바로 게임 시작
                document.getElementById('character-select-modal').style.display = 'none';
                initializeDOM();
            }
        }

        // 행동 버튼 상태 업데이트
        function updateActionButtons() {
            gameState.characters.forEach(character => {
                if (!character.dead) {
                    const actionsContainer = document.querySelector(`#actions-${character.id}`);
                    if (actionsContainer) {
                        const buttons = actionsContainer.querySelectorAll('.action-button');
                        buttons.forEach(button => {
                            const actionKey = button.dataset.action;
                            if (actionKey && actions[actionKey]) {
                                const isAvailable = actions[actionKey].isAvailable(character);
                                button.style.display = isAvailable ? 'block' : 'none';
                            }
                        });
                    }
                }
            });
        }

        // 게임 초기화 및 시작
        window.onload = function() {
            initializeCharacterSelect();
            document.getElementById('character-select-modal').style.display = 'flex';
        };
    </script>
</body>
</html>